package com.logicea.cards.services.impl;

import com.logicea.cards.dto.CardDto;
import com.logicea.cards.dto.CardResponse;
import com.logicea.cards.dto.SearchDto;
import com.logicea.cards.models.Cards;
import com.logicea.cards.models.Roles;
import com.logicea.cards.models.Status;
import com.logicea.cards.models.Users;
import com.logicea.cards.repositories.CardRepository;
import com.logicea.cards.services.CardService;
import com.logicea.cards.utils.CommonUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class CardServiceImpl implements CardService {
    private final static Logger LOG = LoggerFactory.getLogger(CardServiceImpl.class);
    private final CardRepository cardRepository;
    private final JdbcTemplate jdbcTemplate;
    private final RowMapper<CardDto> cardRowMapper = (rs, i) ->
            new CardDto(rs.getLong("id"), rs.getString("name"),
                    rs.getString("description"), rs.getString("colour"),
                    Status.valueOf(rs.getString("status")), rs.getDate("created_at").toLocalDate().atStartOfDay());

    public CardServiceImpl(CardRepository cardRepository, JdbcTemplate jdbcTemplate) {
        this.cardRepository = cardRepository;
        this.jdbcTemplate = jdbcTemplate;
    }

    /**
     * Saves a new card
     *
     * @param user
     * @param cardDto {{@link  CardDto }} holds information entered by the user
     * @return {{@link }} Information entered by the user & other information generated by the DB
     */
    @Override
    public CardResponse<CardDto> saveCard(Users user, CardDto cardDto) {
        try {
            if (!CommonUtil.validateEmpty(cardDto.name())) {
                LOG.error("Card name can not be null");
                return new CardResponse<>("01", "Card name can not be null", cardDto);
            }

            if (this.cardRepository.getCardByNameAndUserId(cardDto.name(), user.getId()) == 1) {
                LOG.error("Card exists");
                return new CardResponse<>("01", "Failed. Card exists", cardDto);
            }

            Cards card = new Cards();
            card.setName(cardDto.name());
            card.setDescription(cardDto.description());
            card.setColour(cardDto.colour());
            card.setStatus(Status.TO_DO);
            card.setCreatedAt(LocalDateTime.now());
            card.setUser(user);
            cardRepository.save(card);
            return new CardResponse<>("00", "Success", new CardDto(card.getId(), cardDto.name(), cardDto.description(), cardDto.colour(), card.getStatus(), card.getCreatedAt()));
        } catch (Exception ex) {
            LOG.error(ex.getMessage(), ex);
            return new CardResponse<>("01", "Failed", cardDto);
        }
    }

    /**
     * Updates card information
     *
     * @param id   - Card unique identifier
     * @param card - New card information
     * @return {{@link }} new card information
     */
    @Override
    public CardResponse<CardDto> saveCard(long id, CardDto cardDto) {
        try {
            Cards card = this.cardRepository.getReferenceById(id);
            if (!CommonUtil.validateEmpty(cardDto.name())) {
                LOG.error("Card with id {} not found", id);
                return new CardResponse<>("01", "Failed", cardDto);
            }

            if (!CommonUtil.validateColour(cardDto.colour())) {
                LOG.error("Card name can not be null");
                return new CardResponse<>("01", "Failed", cardDto);
            }

            card.setName(cardDto.name());
            card.setStatus(cardDto.status());
            card.setDescription(cardDto.description());
            card.setColour(cardDto.colour());
            card.setUpdateAt(LocalDateTime.now());
            this.cardRepository.save(card);
            return new CardResponse<>("00", "Success. Card updated", new CardDto(card.getId(), cardDto.name(), cardDto.description(), cardDto.colour(), card.getStatus(), card.getCreatedAt()));
        } catch (Exception ex) {
            LOG.error(ex.getMessage(), ex);
            return new CardResponse<>("01", "Failed", cardDto);
        }
    }

    /**
     * Soft deletes a card from the DB
     *
     * @param id - Card unique identifier
     */
    @Override
    public CardResponse<CardDto> deleteCard(long id) {
        try {
            Cards card = this.cardRepository.getReferenceById(id);

            if (!ObjectUtils.isEmpty(card)) {
                LOG.error("Card with id {} not found", id);
                return new CardResponse<>("01", String.format("Failed. Card with id %s not found", id), null);
            }

            card.setDeleted(true);
            card.setDeleteAt(LocalDateTime.now());
            return new CardResponse<>("00", "Success. Card updated", new CardDto(card.getId(), card.getName(), card.getDescription(), card.getColour(), card.getStatus(), card.getCreatedAt()));
        } catch (Exception ex) {
            LOG.error(ex.getMessage(), ex);
            return new CardResponse<>("01", "Failed to delete card", null);
        }
    }

    @Override
    public CardResponse<List<CardDto>> search(Users user, SearchDto searchDto) {
        try {
            String sql = buildQuery(user, searchDto);
            var list = jdbcTemplate.query(sql, cardRowMapper);
            return new CardResponse<>("00", "success", list);
        } catch (Exception ex) {
            LOG.error(ex.getMessage(), ex);
            return new CardResponse<>("01", "Failed", null);
        }
    }

    @Override
    public boolean getCarByNameAndUser(String colour, long id) {
        return false;
    }

    private String buildQuery(Users user, SearchDto searchDto) {
        String sql = "SELECT * FROM cards WHERE ";
        Map<String, String> params = new HashMap<>();
        if (CommonUtil.validateEmpty(searchDto.name())) {
            params.put("name", searchDto.name());
        }

        if (CommonUtil.validateEmpty(searchDto.colour())) {
            params.put("colour", searchDto.colour());
        }

        if (CommonUtil.validateEmpty(searchDto.status())) {
            params.put("status", searchDto.status().name());
        }

        if (CommonUtil.validateEmpty(searchDto.createDate())) {
            params.put("created_at", searchDto.createDate().toString());
        }

        if (user.getRole() == Roles.USER) {
            params.put("user_id", user.getId().toString());
        }

        boolean start = true;
        for (var column : params.entrySet()) {
            String oper = "='";
            if (column.getKey().equalsIgnoreCase("created_at")) {
                oper = ">='";
            }
            sql += column.getKey() + oper + column.getValue() + "' ";
            if (start) {
                start = false;
                sql += " AND ";
            } else {
                sql += " AND ";
            }
        }


        sql += " 1=1"; // hack to fix the dynamically built query

        if (searchDto.orderColumn() != null) {
            sql += " ORDER BY " + searchDto.orderColumn() + " ";
            if (searchDto.direction() != null) {
                if (searchDto.direction().equalsIgnoreCase("ASC") || searchDto.direction().equalsIgnoreCase("DESC")) {
                    sql += searchDto.direction();
                }
            }
        }

        return sql;
    }
}
